<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Вопрос 11</title>
    <link rel="stylesheet" href="../static/css/styles.css">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
</head>
<body>
<div class="navbar">
    <a href="../index.html">Содержание</a>
    <a href="question1.html">Вопрос 1</a>
    <a href="question2.html">Вопрос 2</a>
    <a href="question3.html">Вопрос 3</a>
    <a href="question4.html">Вопрос 4</a>
    <a href="question5.html">Вопрос 5</a>
    <a href="question6.html">Вопрос 6</a>
    <a href="question7.html">Вопрос 7</a>
    <a href="question8.html">Вопрос 8</a>
    <a href="question9.html">Вопрос 9</a>
    <a href="question10.html">Вопрос 10</a>
    <a href="question11.html">Вопрос 11</a>
</div>
<div class="content">
    <div class="header">
        <h1>Вопрос 10</h1>
    </div>
    <div class="main">
        <h2>Методы сжатия данных</h2>
        <h4>Метод и коды Хаффмана</h4>
        <p>
            Алгоритм Хаффмана - это алгоритм сжатия данных, который формулирует основную идею сжатия файлов. Он
            использует кодирование переменной длины, которое позволяет использовать меньшее количество битов для
            кодирования наиболее часто встречающихся символов и большее количество битов для кодирования редких
            символов. Это позволяет уменьшить размер файла и ускорить передачу данных.
        </p>
        <p>
            Для сжатия файла с помощью алгоритма Хаффмана, сначала необходимо подсчитать частоту встречаемости каждого
            символа в файле. Затем, используя эти частоты, строится дерево Хаффмана, в котором каждый символ представлен
            узлом дерева, а его частота - весом узла. Часто встречающиеся символы имеют более короткие коды, чем редкие
            символы, что позволяет сократить размер файла
        </p>
        <p> Для кодирования файла используются коды Хаффмана, которые представляют собой последовательность битов,
            соответствующих каждому символу. Коды Хаффмана строятся путем прохождения по дереву Хаффмана от корня к
            листьям, где каждый лист соответствует символу и содержит его код. При кодировании файла каждый символ
            заменяется на его код Хаффмана, что позволяет сократить размер файла
        </p>
        <p>
            Для декодирования файла необходимо использовать ту же таблицу Хаффмана, что и для кодирования. Декодирование
            происходит путем прохождения по дереву Хаффмана от корня к листьям, где каждый лист соответствует символу и
            содержит его код. При декодировании файла каждый код Хаффмана заменяется на соответствующий символ, что
            позволяет восстановить исходный файл
        </p>
        <p>Дерево строится следующим образом: </p>
        <ol>
            <li>Каждый символ строки становится узлом будущего дерева</li>
            <li>
                Узлы размещаются в порядке возрастания чатсотности в очереди так, чтобы у выхода очереди находились
                самые редкие символы
            </li>
            <li>
                Два узла с наименьшей частотой извлекаются из очереди и объединяются одним узлом, формируя мини-дерево
                из двух узлов и корня, частота которого равна сумме частот двух извлеченных узлов
            </li>
            <li>
                Мини-дерево добавляется в очередь в нужное место в зависимости от частоты корня
            </li>
            <li>
                Шаги 3 и 4 повторяются до тех пор, пока в очереди не останется один узел - корень дерева Хаффмана
            </li>
        </ol>
        <img src="../src/haffman_1.jpeg" alt="haffman">
        <p>
            Примечание: в последнем этапе на картинке опечатка - на правом дереве вместо символа пробела
            должен быть символ S.
        </p>
        <img src="../src/haffman_2.jpeg" alt="haffman">

        <h4>Метод RLE</h4>
        <p>
            Метод RLE (Run-Length Encoding) — это алгоритм сжатия данных, который заменяет повторяющиеся символы (серии)
            на один символ и число его повторов. Этот алгоритм является простым и эффективным для данных, содержащих
            много повторяющихся символов.
        </p>
        <pre>
        Пример RLE сжатия:
        Исходная строка: aaababbcbbb
        Сжатая строка: (a, 3) (b, 1) (a, 1) (b, 2) (c, 1) (b, 3) </pre>
        <p>
            В данном примере, алгоритм RLE заменяет три подряд идущих символа 'a' на пару (a, 3), один символ 'b' на
            пару (b, 1), один символ 'a' на пару (a, 1) и так далее.
        </p>
        <p>
            RLE часто используется для сжатия изображений, особенно тех, которые содержат большие области однородных
            цветов, таких как черно-белые изображения или изображения с простыми геометрическими формами. Однако, для
            данных с частыми изменениями между значениями, RLE может быть неэффективным.
        </p>


        <h4>Алгоритмы LZ (LZ77 и LZW)</h4>
        <p>Алгоритмы LZ, такие как LZ77 и LZW, являются алгоритмами сжатия без потерь, которые широко применяются в
            области сжатия данных и хранения информации. Они были разработаны Абрахамом Лемпелем и Якобом Зивом в 1977
            году и позднее усовершенствованы.</p>

        <h4>Алгоритм LZ77</h4>
        <p>Алгоритм LZ77 использует словарь для замены повторяющихся фрагментов данных. Он осуществляет сжатие путем
            представления повторяющихся фрагментов в виде пар (смещение, длина) внутри словаря.</p>

        <p>Рассмотрим пример алгоритма LZ77 на строке "ABABABA". Для начала создадим пустой словарь и инициализируем его
            первыми двумя символами строки.</p>

        <pre>
    Исходная строка: ABABABA
    Словарь: A, B
    Сжатие:</pre>

        <p>1. Первый символ "A" не находится в словаре, поэтому он добавляется в словарь, и сжатие остается пустым.</p>

        <pre>
    Исходная строка: ABABABA
    Словарь: A, B
    Сжатие:</pre>

        <p>2. Второй символ "B" также не находится в словаре, поэтому он добавляется в словарь, и сжатие остается
            пустым.</p>

        <pre>
    Исходная строка: ABABABA
    Словарь: A, B
    Сжатие:</pre>

        <p>3. Третий символ "A" уже находится в словаре, поэтому мы ищем самую длинную подстроку, начинающуюся с этого
            символа, которая уже есть в словаре. В данном случае, такой подстрокой является "ABA" (смещение = 1, длина =
            3). Мы добавляем пару (1, 3) в сжатие и продолжаем с четвертого символа.</p>

        <pre>
    Исходная строка: ABABABA
    Словарь: A, B, ABA
    Сжатие: (1, 3)</pre>

        <p>4. Четвертый символ "B" уже находится в словаре, и самая длинная повторяющаяся подстрока, начинающаяся с
            этого символа, является "ABA" (смещение = 1, длина = 3). Мы добавляем пару (1, 3) в сжатие и продолжаем с
            пятого символа.</p>

        <pre>
    Исходная строка: ABABABA
    Словарь: A, B, ABA
    Сжатие: (1, 3), (1, 3)</pre>

        <p>5. Пятый символ "B" уже находится в словаре, и самая длинная повторяющаяся подстрока, начинающаяся с этого
            символа, является "ABAB" (смещение = 2, длина = 4). Мы добавляем пару (2, 4) в сжатие и продолжаем с шестого
            символа.</p>

        <pre>
    Исходная строка: ABABABA
    Словарь: A, B, ABA, ABAB
    Сжатие: (1, 3), (1, 3), (2, 4)</pre>

        <p>6. Шестой символ "A" уже находится в словаре, и самая длинная повторяющаяся подстрока, начинающаяся с этого
            символа, является "ABABA" (смещение = 2, длина = 5). Мы добавляем пару (2, 5) в сжатие и продолжаем с
            седьмого символа.</p>

        <pre>
    Исходная строка: ABABABA
    Словарь: A, B, ABA, ABAB, ABABA
    Сжатие: (1, 3), (1, 3), (2, 4), (2, 5)</pre>

        <p>7. Седьмой символ "B" уже находится в словаре, и самая длинная повторяющаяся подстрока, начинающаяся с этого
            символа, является "ABAB" (смещение = 3, длина = 4). Мы добавляем пару (3, 4) в сжатие.</p>

        <pre>
    Исходная строка: ABABABA
    Словарь: A, B, ABA, ABAB, ABABA
    Сжатие: (1, 3), (1, 3), (2, 4), (2, 5), (3, 4)</pre>

        <p>Таким образом, сжатие алгоритмом LZ77 для строки "ABABABA" будет состоять из пар (смещение, длина): (1, 3),
            (1, 3), (2, 4), (2, 5), (3, 4).</p>

        <h4>Алгоритм LZW</h4>
        <p>Алгоритм LZW является улучшенной версией алгоритма LZ77. Он также использует таблицу, но добавляет новые
            фразы в словарь при сжатии, а не только заменяет повторяющиеся фрагменты.</p>

        <p>
            Рассмотрим пример алгоритма LZW на строке "aaababbaab". Для начала создадим пустой словарь и инициализируем
            его
            однобуквенными символами.
        </p>


        <table>
            <tr>
                <th>Код</th>
                <th>Текст</th>
            </tr>
            <tr>
                <td>0</td>
                <td>a</td>
            </tr>
            <tr>
                <td>1</td>
                <td>b</td>
            </tr>
        </table>
        <p>"<b>a</b>aababbaab" - а есть в таблице, идем по строке пока не найдем отустствующий в таблице текст</p>
        <p>
            "<b>аa</b>ababbaab" - аа нет в таблице, выводим код для предыдущей (0) и заносим в таблицу аа,
            добавляем следующий символ строки, так как аа не было в таблице
        </p>
        <table>
            <tr>
                <th>Код</th>
                <th>Текст</th>
            </tr>
            <tr>
                <td>0</td>
                <td>a</td>
            </tr>
            <tr>
                <td>1</td>
                <td>b</td>
            </tr>
            <tr>
                <td>2</td>
                <td>аа</td>
            </tr>
        </table>
        <p>"<b>аab</b>abbaab" - ааb нет в таблице, идем по строке пока не найдем отустствующий в таблице текст</p>


        <p>Алгоритмы LZ77 и LZW являются эффективными методами сжатия данных. Они позволяют уменьшить размер данных,
            сохраняя при этом информацию о повторяющихся фрагментах. Оба алгоритма широко используются в области сжатия
            текстовых и графических данных, а также в архивации и других приложениях.</p>
    </div>
</div>
</body>
</html>
